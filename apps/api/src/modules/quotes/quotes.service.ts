import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../../prisma/prisma.service';
import { PricingService } from '../pricing/pricing.service';
import { QuoteCacheService } from '../redis/quote-cache.service';
import { Cacheable, CacheInvalidate } from '../redis/decorators/cache.decorator';
import { Quote as PrismaQuote, QuoteItem as PrismaQuoteItem, Prisma } from '@prisma/client';
import { QuoteStatus, Currency, ProcessType } from '@cotiza/shared';
import { CreateQuoteDto } from './dto/create-quote.dto';
import { AddQuoteItemDto } from './dto/add-quote-item.dto';
import { CalculateQuoteDto } from './dto/calculate-quote.dto';
import { UpdateQuoteDto } from './dto/update-quote.dto';
import { Decimal } from 'decimal.js';
import { createPaginatedResponse, getPrismaSkipTake } from '../../common/utils/pagination.util';
import { PaginatedDto } from '../../common/dto/paginated.dto';
import { TenantCacheService } from '../tenants/services/tenant-cache.service';
import { JobsService } from '../jobs/jobs.service';
import { JobType } from '../jobs/interfaces/job.interface';
import { FilesService } from '../files/files.service';

@Injectable()
export class QuotesService {
  constructor(
    private prisma: PrismaService,
    private pricingService: PricingService,
    private quoteCacheService: QuoteCacheService,
    private tenantCacheService: TenantCacheService,
    private jobsService: JobsService,
    private filesService: FilesService,
  ) {}

  async create(tenantId: string, customerId: string, dto: CreateQuoteDto): Promise<PrismaQuote> {
    // Get quote validity days from tenant configuration
    const tenantConfig = await this.tenantCacheService.getTenantConfig(tenantId);
    const validityDays = (tenantConfig.settings.quoteValidityDays as number) || 14;
    const validityUntil = new Date();
    validityUntil.setDate(validityUntil.getDate() + validityDays);

    // Generate unique quote number
    const quoteNumber = await this.generateQuoteNumber(tenantId);

    return this.prisma.quote.create({
      data: {
        tenantId,
        customerId,
        number: quoteNumber,
        currency: dto.currency,
        objective: dto.objective,
        validityUntil,
        status: QuoteStatus.DRAFT,
      },
    });
  }

  async findAll(
    tenantId: string,
    filters: {
      customerId?: string;
      status?: QuoteStatus;
      page?: number;
      limit?: number;
    },
  ): Promise<PaginatedDto<PrismaQuote>> {
    const page = filters.page || 1;
    const limit = filters.limit || 20;
    const { skip, take } = getPrismaSkipTake({ page, limit });

    const where = {
      tenantId,
      ...(filters.customerId && { customerId: filters.customerId }),
      ...(filters.status && { status: filters.status as string }), // Cast enum to string for Prisma
    };

    const [data, total] = await Promise.all([
      this.prisma.quote.findMany({
        where,
        include: {
          items: true,
          customer: {
            select: {
              id: true,
              email: true,
              name: true,
            },
          },
        },
        skip,
        take,
        orderBy: { createdAt: 'desc' },
      }),
      this.prisma.quote.count({ where }),
    ]);

    return createPaginatedResponse({ data, total }, { page, limit });
  }

  @Cacheable({ prefix: 'quote:detail', ttl: 300 }) // Cache for 5 minutes
  async findOne(tenantId: string, id: string): Promise<PrismaQuote & { items: Array<PrismaQuoteItem & { files: unknown[]; dfmReport: unknown }> }> {
    const quote = await this.prisma.quote.findFirst({
      where: {
        id,
        tenantId,
      },
      include: {
        items: {
          include: {
            files: true,
            dfmReport: true,
          },
        },
        customer: {
          select: {
            id: true,
            email: true,
            name: true,
          },
        },
      },
    });

    if (!quote) {
      throw new NotFoundException('Quote not found');
    }

    return quote;
  }

  @CacheInvalidate('quote:detail:*')
  async update(tenantId: string, id: string, dto: UpdateQuoteDto): Promise<PrismaQuote> {
    const quote = await this.findOne(tenantId, id);

    if (quote.status !== QuoteStatus.DRAFT && quote.status !== QuoteStatus.SUBMITTED) {
      throw new BadRequestException('Cannot update quote in current status');
    }

    return this.prisma.quote.update({
      where: { id },
      data: {
        objective: dto.objective as Prisma.InputJsonValue,
        metadata: dto.metadata as Prisma.InputJsonValue,
      },
    });
  }

  async addItem(tenantId: string, quoteId: string, dto: AddQuoteItemDto): Promise<PrismaQuoteItem> {
    const quote = await this.findOne(tenantId, quoteId);

    if (quote.status !== QuoteStatus.DRAFT) {
      throw new BadRequestException('Cannot add items to non-draft quote');
    }

    // Verify file belongs to tenant
    const file = await this.prisma.file.findFirst({
      where: {
        id: dto.fileId,
        tenantId,
      },
    });

    if (!file) {
      throw new NotFoundException('File not found');
    }

    // Create quote item
    const quoteItem = await this.prisma.quoteItem.create({
      data: {
        quoteId,
        name: dto.name || file.originalName,
        process: dto.process,
        processCode: dto.process,
        material: (dto.options as Record<string, unknown>)?.material as string || 'PLA', // Extract material from options
        quantity: dto.quantity,
        selections: dto.options as Prisma.InputJsonValue,
      },
    });

    // Associate file with quote item
    await this.prisma.file.update({
      where: { id: dto.fileId },
      data: { quoteItemId: quoteItem.id },
    });

    // Return the item with relations loaded
    return this.prisma.quoteItem.findUnique({
      where: { id: quoteItem.id },
      include: {
        files: true,
      },
    }) as Promise<PrismaQuoteItem>;
  }

  async calculate(tenantId: string, quoteId: string, dto: CalculateQuoteDto): Promise<{ quote: PrismaQuote & { items: Array<PrismaQuoteItem & { files: unknown[]; dfmReport: unknown }> }; errors?: Array<{ itemId?: string; error: string }> }> {
    const quote = await this.findOne(tenantId, quoteId);

    // Update objective if provided
    if (dto.objective) {
      await this.prisma.quote.update({
        where: { id: quoteId },
        data: { objective: dto.objective as unknown as Prisma.InputJsonValue },
      });
    }

    // Get all quote items to calculate
    const itemsToCalculate = dto.items || quote.items;
    const calculatedItems = [];
    const errors = [];

    for (const item of itemsToCalculate) {
      try {
        // Get or create quote item
        let quoteItem;
        if ('id' in item && item.id) {
          // Existing quote item
          quoteItem = await this.prisma.quoteItem.findFirst({
            where: { id: item.id, quoteId },
            include: { files: true, dfmReport: true },
          });
          if (!quoteItem) {
            throw new Error(`Quote item not found for id: ${item.id}`);
          }
        } else {
          // Create new item
          quoteItem = await this.addItem(tenantId, quoteId, item as AddQuoteItemDto);
        }

        // Try to get cached pricing result first
        const cacheKey = {
          fileHash: (quoteItem as { files?: Array<{ hash?: string }> }).files?.[0]?.hash || '',
          service: quoteItem.processCode,
          material: (quoteItem.selections as Record<string, unknown>)?.material as string || 'default',
          quantity: quoteItem.quantity,
          options: quoteItem.selections as Record<string, unknown> | undefined,
        };

        const pricingResult = await this.quoteCacheService.getOrCalculateQuote(
          cacheKey,
          async () => {
            const result = await this.pricingService.calculateQuoteItem(
              tenantId,
              quoteItem.processCode as ProcessType,
              {}, // geometryMetrics - placeholder
              quoteItem.materialId || '',
              '', // machineId - placeholder
              quoteItem.selections,
              quoteItem.quantity,
              quote.objective as { cost?: number; lead?: number; green?: number },
            );
            return {
              pricing: {
                unitCost: result.unitPrice,
                totalCost: result.totalPrice,
                margin: result.costBreakdown.margin,
                finalPrice: result.totalPrice,
              },
              manufacturing: {
                estimatedTime: result.leadDays,
                machineCost: result.costBreakdown?.machine || 0,
                materialCost: result.costBreakdown?.material || 0,
              },
              timestamp: Date.now(),
            };
          },
        );

        // Update quote item with results
        const updatedItem = await this.prisma.quoteItem.update({
          where: { id: quoteItem.id },
          data: {
            unitPrice: pricingResult.pricing.unitCost,
            totalPrice: pricingResult.pricing.totalCost,
            leadDays: pricingResult.manufacturing.estimatedTime,
            costBreakdown: {
              machine: pricingResult.manufacturing.machineCost,
              material: pricingResult.manufacturing.materialCost,
            } as Prisma.InputJsonValue,
            sustainability: {} as Prisma.InputJsonValue,
            flags: [],
          },
        });

        calculatedItems.push(updatedItem);
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
        errors.push({
          itemId: 'id' in item ? item.id : '',
          error: errorMessage,
        });
      }
    }

    // Calculate totals
    const totals = await this.calculateTotals(tenantId, calculatedItems, quote.currency as Currency);

    // Update quote status and totals
    const updatedQuote = await this.prisma.quote.update({
      where: { id: quoteId },
      data: {
        status: errors.length > 0 ? QuoteStatus.NEEDS_REVIEW : QuoteStatus.AUTO_QUOTED,
        totals,
        sustainability: this.calculateSustainabilitySummary(calculatedItems) as Prisma.InputJsonValue,
      },
      include: {
        items: {
          include: {
            files: true,
            dfmReport: true,
          },
        },
      },
    });

    return {
      quote: updatedQuote,
      errors: errors.length > 0 ? errors : undefined,
    };
  }

  async approve(
    tenantId: string,
    quoteId: string,
    customerId: string,
  ): Promise<{ quote: PrismaQuote; sessionId?: string; paymentUrl?: string }> {
    const quote = await this.findOne(tenantId, quoteId);

    if (quote.customerId !== customerId) {
      throw new BadRequestException('Unauthorized to approve this quote');
    }

    if (quote.status !== QuoteStatus.QUOTED && quote.status !== QuoteStatus.AUTO_QUOTED) {
      throw new BadRequestException('Quote cannot be approved in current status');
    }

    if (new Date(quote.validityUntil) < new Date()) {
      throw new BadRequestException('Quote has expired');
    }

    const updatedQuote = await this.prisma.quote.update({
      where: { id: quoteId },
      data: { status: QuoteStatus.APPROVED },
    });

    // Return just the quote for now - payment integration will be handled separately
    return { quote: updatedQuote };
  }

  @CacheInvalidate('quote:detail:*')
  async cancel(tenantId: string, quoteId: string): Promise<PrismaQuote> {
    const quote = await this.findOne(tenantId, quoteId);

    const allowedStatuses: QuoteStatus[] = [
      QuoteStatus.DRAFT,
      QuoteStatus.SUBMITTED,
      QuoteStatus.AUTO_QUOTED,
      QuoteStatus.QUOTED,
      QuoteStatus.NEEDS_REVIEW,
    ];
    if (!allowedStatuses.includes(quote.status as QuoteStatus)) {
      throw new BadRequestException('Quote cannot be cancelled in current status');
    }

    return this.prisma.quote.update({
      where: { id: quoteId },
      data: { status: QuoteStatus.CANCELLED },
    });
  }

  private async calculateTotals(
    tenantId: string,
    items: Array<PrismaQuoteItem>,
    currency: Currency,
  ): Promise<{
    subtotal: number;
    tax: number;
    shipping: number;
    grandTotal: number;
    currency: Currency;
  }> {
    const subtotal = items.reduce(
      (sum, item) => sum.plus(new Decimal(item.totalPrice || 0)),
      new Decimal(0),
    );

    // Get tenant pricing settings for tax and shipping calculation
    const pricingSettings = await this.tenantCacheService.getPricingSettings(tenantId);
    
    // Calculate tax based on tenant configuration
    const taxRate = new Decimal((pricingSettings.taxRate as number) || 0.16); // Default 16% IVA
    const tax = subtotal.mul(taxRate);

    // Calculate shipping based on tenant configuration
    const freeShippingThreshold = new Decimal((pricingSettings.freeShippingThreshold as number) || 1000);
    const standardShippingRate = new Decimal((pricingSettings.standardShippingRate as number) || 150);
    
    // Apply free shipping if order meets threshold, otherwise apply standard rate
    const shipping = subtotal.gte(freeShippingThreshold) ? new Decimal(0) : standardShippingRate;

    const grandTotal = subtotal.plus(tax).plus(shipping);

    return {
      subtotal: subtotal.toNumber(),
      tax: tax.toNumber(),
      shipping: shipping.toNumber(),
      grandTotal: grandTotal.toNumber(),
      currency,
    };
  }

  private calculateSustainabilitySummary(items: Array<{ sustainability?: { co2eKg?: number; score?: number; energyKwh?: number } | null }>): {
    score: number;
    co2eKg: number;
    energyKwh: number;
  } | null {
    if (items.length === 0) return null;

    const totalCo2e = items.reduce(
      (sum, item) => sum.plus(new Decimal(item.sustainability?.co2eKg || 0)),
      new Decimal(0),
    );

    const avgScore =
      items.reduce((sum, item) => sum + (item.sustainability?.score || 0), 0) / items.length;

    const totalEnergyKwh = items.reduce(
      (sum, item) => sum.plus(new Decimal(item.sustainability?.energyKwh || 0)),
      new Decimal(0),
    );

    return {
      score: Math.round(avgScore),
      co2eKg: totalCo2e.toNumber(),
      energyKwh: totalEnergyKwh.toNumber(),
    };
  }

  private async generateQuoteNumber(tenantId: string): Promise<string> {
    // Get the current date components
    const now = new Date();
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');

    // Get the count of quotes for this tenant in the current month
    const startOfMonth = new Date(year, now.getMonth(), 1);
    const endOfMonth = new Date(year, now.getMonth() + 1, 0, 23, 59, 59, 999);

    const count = await this.prisma.quote.count({
      where: {
        tenantId,
        createdAt: {
          gte: startOfMonth,
          lte: endOfMonth,
        },
      },
    });

    // Generate quote number in format: Q-YYYY-MM-XXXX
    const sequence = String(count + 1).padStart(4, '0');
    return `Q-${year}-${month}-${sequence}`;
  }

  async generatePdf(tenantId: string, quoteId: string): Promise<{ url: string; expiresAt: string }> {
    // Get quote with all related data
    const quote = await this.prisma.quote.findFirst({
      where: { id: quoteId, tenantId },
      include: {
        customer: true,
        items: {
          include: {
            files: true,
          },
        },
        tenant: {
          select: {
            name: true,
            code: true,
            settings: true,
          },
        },
      },
    });

    if (!quote) {
      throw new NotFoundException('Quote not found');
    }

    // Check if PDF already exists and is recent (less than 24 hours old)
    const existingPdf = await this.prisma.file.findFirst({
      where: {
        tenantId,
        metadata: {
          path: ['$.quoteId'],
          equals: quoteId,
        },
        type: 'pdf',
        createdAt: {
          gte: new Date(Date.now() - 24 * 60 * 60 * 1000), // 24 hours ago
        },
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    if (existingPdf) {
      // Return existing PDF URL
      const url = await this.filesService.getFileUrl(tenantId, existingPdf.id);
      return {
        url,
        expiresAt: new Date(Date.now() + 3600000).toISOString(), // 1 hour from now
      };
    }

    // Queue PDF generation job
    const job = await this.jobsService.addJob(JobType.REPORT_GENERATION, {
      tenantId,
      reportType: 'quote',
      entityId: quoteId,
      format: 'pdf',
      data: {
        id: quote.id,
        number: quote.number,
        createdAt: quote.createdAt,
        validUntil: quote.validityUntil,
        status: quote.status,
        currency: quote.currency,
        customer: (quote as any).customer,
        items: (quote as any).items?.map((item: any) => ({
          name: item.part?.filename || 'Part',
          quantity: item.quantity,
          unitPrice: item.unitPrice,
          currency: quote.currency,
          material: {
            name: item.material?.name || item.material,
          },
          manufacturingProcess: {
            name: item.process?.name || item.process,
          },
          files: [{
            originalName: item.part?.filename || 'file',
          }],
        })),
        subtotal: quote.subtotal,
        tax: quote.tax,
        shipping: quote.shipping,
        total: quote.totalPrice,
        tenantId: quote.tenantId,
      },
      options: {
        includeItemDetails: true,
        language: 'en', // Could be determined from user preferences
      },
    });

    // For now, return a placeholder URL while the PDF is being generated
    // In production, you might want to implement a webhook or polling mechanism
    return {
      url: `${process.env.API_URL}/api/v1/quotes/${quoteId}/pdf/status?jobId=${job.id}`,
      expiresAt: new Date(Date.now() + 3600000).toISOString(),
    };
  }
}
